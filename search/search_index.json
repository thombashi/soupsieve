{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Soup Sieve \ue157 Overview \ue157 Soup Sieve is a CSS selector library designed to be used with Beautiful Soup 4 . It aims to provide selecting, matching, and filtering using modern CSS selectors. Soup Sieve currently provides selectors from the CSS level 1 specifications up through the latest CSS level 4 drafts (though some are not yet implemented). While Beautiful Soup comes with a builtin CSS selection API, it is very basic and not without issues. It lacks support for many modern CSS features. Soup Sieve is planned to officially replace Beautiful Soup's current internal CSS selector implementation, but can also be imported in order to use its API directly. Soup Sieve implements most of the CSS selectors, though there are a number that don't make sense in a non-browser environment. Selectors that cannot provide meaningful functionality simply do not match anything. Some of the supported selectors are: . classes # ids [ attributes = value ] parent child parent > child sibling ~ sibling sibling + sibling : not ( element . class , element2 . class ) : is ( element . class , element2 . class ) parent : has (> child ) and many more Checkout CSS Selectors to see the full list. Installation \ue157 You must have Beautiful Soup already installed: pip install beautifulsoup4 Then use pip to install Soup Sieve: pip install soupsieve If you want to manually install it, run python setup.py build and python setup.py install . Usage \ue157 To use Soup Sieve, you must create a BeautifulSoup object: >>> import bs4 >>> text = \"\"\" ... <div> ... <!-- These are animals --> ... <p class=\"a\">Cat</p> ... <p class=\"b\">Dog</p> ... <p class=\"c\">Mouse</p> ... </div> ... \"\"\" >>> soup = bs4 . BeautifulSoup ( text , 'html5lib' ) Then you can begin to use Soup Sieve to select a single tag: >>> import soupsieve as sv >>> sv . select_one ( 'p:is(.a, .b, .c)' , soup ) <p class=\"a\">Cat</p> To select all tags: >>> import soupsieve as sv >>> sv . select ( 'p:is(.a, .b, .c)' , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] To select closest, direct ancestor: >>> import soupsieve as sv >>> el = sv . select_one ( '.c' , soup ) >>> sv . closest ( 'div' , el ) <div> <!-- These are animals --> <p class=\"a\">Cat</p> <p class=\"b\">Dog</p> <p class=\"c\">Mouse</p> </div> To filter: >>> sv . filter ( 'p:not(.b)' , soup . div ) [<p class=\"a\">Cat</p>, <p class=\"c\">Mouse</p>] To match: >>> els = sv . select ( 'p:is(.a, .b, .c)' , soup ) >>> sv . match ( els [ 0 ], 'p:not(.b)' ) True >>> sv . match ( els [ 1 ], 'p:not(.b)' ) False Or even just extracting comments: >>> sv . comments ( soup ) [' These are animals '] Selectors do not have to be constrained to one line either. You can span selectors over multiple lines just like you would in a CSS file. >>> selector = \"\"\" ... .a, ... .b, ... .c ... \"\"\" >>> sv . select ( selector , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] You can even use comments to annotate a particularly complex selector. >>> selector = \"\"\" ... /* This isn't complicated, but we're going to annotate it anyways. ... This is the a class */ ... .a, ... /* This is the b class */ ... .b, ... /* This is the c class */ ... .c ... \"\"\" >>> sv . select ( selector , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] If you've ever used Python's Re library for regular expressions, you may know that it is often useful to pre-compile a regular expression pattern, especially if you plan to use it more than once. The same is true for Soup Sieve's matchers, though is not required. If you have a pattern that you want to use more than once, it may be wise to pre-compile it early on: >>> selector = sv . compile ( 'p:is(.a, .b, .c)' ) >>> selector . filter ( soup . div ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] A compiled object has all the same methods, though the parameters will be slightly different as they don't need things like the pattern or flags once compiled. See API documentation for more info. Compiled patterns are cached, so if for any reason you need to clear the cache, simply issue the purge command. >>> sv . purge ()","title":"Soup Sieve"},{"location":"#soup-sieve","text":"","title":"Soup Sieve"},{"location":"#overview","text":"Soup Sieve is a CSS selector library designed to be used with Beautiful Soup 4 . It aims to provide selecting, matching, and filtering using modern CSS selectors. Soup Sieve currently provides selectors from the CSS level 1 specifications up through the latest CSS level 4 drafts (though some are not yet implemented). While Beautiful Soup comes with a builtin CSS selection API, it is very basic and not without issues. It lacks support for many modern CSS features. Soup Sieve is planned to officially replace Beautiful Soup's current internal CSS selector implementation, but can also be imported in order to use its API directly. Soup Sieve implements most of the CSS selectors, though there are a number that don't make sense in a non-browser environment. Selectors that cannot provide meaningful functionality simply do not match anything. Some of the supported selectors are: . classes # ids [ attributes = value ] parent child parent > child sibling ~ sibling sibling + sibling : not ( element . class , element2 . class ) : is ( element . class , element2 . class ) parent : has (> child ) and many more Checkout CSS Selectors to see the full list.","title":"Overview"},{"location":"#installation","text":"You must have Beautiful Soup already installed: pip install beautifulsoup4 Then use pip to install Soup Sieve: pip install soupsieve If you want to manually install it, run python setup.py build and python setup.py install .","title":"Installation"},{"location":"#usage","text":"To use Soup Sieve, you must create a BeautifulSoup object: >>> import bs4 >>> text = \"\"\" ... <div> ... <!-- These are animals --> ... <p class=\"a\">Cat</p> ... <p class=\"b\">Dog</p> ... <p class=\"c\">Mouse</p> ... </div> ... \"\"\" >>> soup = bs4 . BeautifulSoup ( text , 'html5lib' ) Then you can begin to use Soup Sieve to select a single tag: >>> import soupsieve as sv >>> sv . select_one ( 'p:is(.a, .b, .c)' , soup ) <p class=\"a\">Cat</p> To select all tags: >>> import soupsieve as sv >>> sv . select ( 'p:is(.a, .b, .c)' , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] To select closest, direct ancestor: >>> import soupsieve as sv >>> el = sv . select_one ( '.c' , soup ) >>> sv . closest ( 'div' , el ) <div> <!-- These are animals --> <p class=\"a\">Cat</p> <p class=\"b\">Dog</p> <p class=\"c\">Mouse</p> </div> To filter: >>> sv . filter ( 'p:not(.b)' , soup . div ) [<p class=\"a\">Cat</p>, <p class=\"c\">Mouse</p>] To match: >>> els = sv . select ( 'p:is(.a, .b, .c)' , soup ) >>> sv . match ( els [ 0 ], 'p:not(.b)' ) True >>> sv . match ( els [ 1 ], 'p:not(.b)' ) False Or even just extracting comments: >>> sv . comments ( soup ) [' These are animals '] Selectors do not have to be constrained to one line either. You can span selectors over multiple lines just like you would in a CSS file. >>> selector = \"\"\" ... .a, ... .b, ... .c ... \"\"\" >>> sv . select ( selector , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] You can even use comments to annotate a particularly complex selector. >>> selector = \"\"\" ... /* This isn't complicated, but we're going to annotate it anyways. ... This is the a class */ ... .a, ... /* This is the b class */ ... .b, ... /* This is the c class */ ... .c ... \"\"\" >>> sv . select ( selector , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] If you've ever used Python's Re library for regular expressions, you may know that it is often useful to pre-compile a regular expression pattern, especially if you plan to use it more than once. The same is true for Soup Sieve's matchers, though is not required. If you have a pattern that you want to use more than once, it may be wise to pre-compile it early on: >>> selector = sv . compile ( 'p:is(.a, .b, .c)' ) >>> selector . filter ( soup . div ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] A compiled object has all the same methods, though the parameters will be slightly different as they don't need things like the pattern or flags once compiled. See API documentation for more info. Compiled patterns are cached, so if for any reason you need to clear the cache, simply issue the purge command. >>> sv . purge ()","title":"Usage"},{"location":"api/","text":"API \ue157 Soup Sieve uses a subset of the CSS4 selector specification to detect and filter elements. To learn more about which specific selectors are implemented, see CSS Selectors . Soup Sieve will detect the document type being used from the Beautiful Soup object that is given to it, and depending on the document type, its behavior may be slightly different: All HTML document types (HTML, HTML5, and XHTML) will have their tag names and attribute names treated without case sensitivity, like most browsers do. Though XHTML is XML, which traditionally is case sensitive, it will still be treated like HTML in this respect. XML document types will have their tag names and attribute names treated with case sensitivity. HTML5, XHTML and XML document types will have namespaces evaluated per the document's support (provided via the parser). html5lib provides proper namespaces for HTML5, but lxml will not. If you need namespace support for HTML5, consider using html5lib . For XML, lxml will provide proper namespaces. It is generally suggested that lxml is used to parse XHTML documents. Some additional configuration is required when using namespaces, see Namespace for more information. While attribute values are generally treated as case sensitive, HTML5, XHTML, and HTML treat the type attribute special. The type attribute's value is always case insensitive. This is generally how most browsers treat type . If you need type to be sensitive, you can use the s flag: [ type = \"submit\" s ] . As far as the API is concerned, Soup Sieve mimics Beautiful Soup's original API at the time of writing this, which is why the names select and select_one are used. As of today, Beautiful Soup has agreed to include Soup Sieve as the official select library which is slated for the 4.7.0 release. Soup Sieve will always be available as an external API as well for more controlled tag selection if needed. Flags \ue157 Early in development, flags were used to specify document type, but as of 1.0.0, there are no flags used at this time, but the parameter is provided for potential future use. soupsieve.select_one() \ue157 def select ( select , tag , namespaces = None , flags = 0 ): \"\"\"Select the specified tags.\"\"\" select_one will return the first tag under the given tag that matches the given CSS selectors provided, or it will return None if a suitable tag was not found. select_one accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, and flags . >>> import soupsieve as sv >>> sv . select_one ( 'p:is(.a, .b, .c)' , soup ) <p class=\"a\">Cat</p> soupsieve.select() \ue157 def select ( select , tag , namespaces = None , limit = 0 , flags = 0 ): \"\"\"Select the specified tags.\"\"\" select will return all tags under the given tag that match the given CSS selectors provided. You can also limit the number of tags returned by providing a positive integer via the limit parameter (0 means to return all tags). select accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, a limit , and flags . >>> import soupsieve as sv >>> sv . select ( 'p:is(.a, .b, .c)' , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] soupsieve.iselect() \ue157 def iselect ( select , node , namespaces = None , limit = 0 , flags = 0 ): \"\"\"Select the specified tags.\"\"\" iselect is exactly like select except that it returns a generator instead of a list. soupsieve.closest() \ue157 def closest ( select , tag , namespaces = None , flags = 0 ): \"\"\"Match closest ancestor to the provided tag.\"\"\" closest returns the tag closest to the given tag that matches the given selector. The element found must be a direct ancestor of the tag or the tag itself. closest accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, and flags . soupsieve.match() \ue157 def match ( select , tag , namespaces = None , flags = 0 ): \"\"\"Match node.\"\"\" The match function matches a given tag with a given CSS selector. match accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, and flags. >>> nodes = sv . select ( 'p:is(.a, .b, .c)' , soup ) >>> sv . match ( 'p:not(.b)' , nodes [ 0 ]) True >>> sv . match ( 'p:not(.b)' , nodes [ 1 ]) False soupsieve.filter() \ue157 def filter ( select , nodes , namespaces = None , flags = 0 ): \"\"\"Filter list of nodes.\"\"\" filter takes an iterable containing HTML nodes and will filter them based on the provided CSS selector string. If given a Tag / BeautifulSoup object, it will iterate the direct children filtering them. filter accepts a CSS selector string, an iterable containing nodes, an optional namespace dictionary, and flags. >>> sv . filter ( 'p:not(.b)' , soup . div ) [<p class=\"a\">Cat</p>, <p class=\"c\">Mouse</p>] soupsieve.comments() \ue157 def comments(tag, limit=0, flags=0): \"\"\"Get comments only.\"\"\" The comments function can be used to extract all comments from a document or document tag. It will return comments from the given tag down through all of its children. You can limit how many comments are returned with limit . comments accepts a Tag / BeautifulSoup object, a limit , and flags. soupsieve.icomments() \ue157 def icomments(node, limit=0, flags=0): \"\"\"Get comments only.\"\"\" icomments is exactly like comments except that it returns a generator instead of a list. soupsieve.compile() \ue157 def compile ( pattern , namespaces = None , flags = 0 ): \"\"\"Compile CSS pattern.\"\"\" compile will pre-compile a CSS selector pattern returning a SoupSieve object. The SoupSieve object has the same selector functions available via the module without the need to specify the selector, namespaces, or flags. class SoupSieve : \"\"\"Match tags in Beautiful Soup with CSS selectors.\"\"\" def match ( self , tag ): \"\"\"Match.\"\"\" def closest ( self , tag ): \"\"\"Match closest ancestor.\"\"\" def filter ( self , iterable ): \"\"\"Filter.\"\"\" def comments ( self , tag , limit = 0 ): \"\"\"Get comments only.\"\"\" def icomments ( self , tag , limit = 0 ): \"\"\"Iterate comments only.\"\"\" def select_one ( self , tag ): \"\"\"Select a single tag.\"\"\" def select ( self , tag , limit = 0 ): \"\"\"Select the specified tags.\"\"\" def iselect ( self , tag , limit = 0 ): \"\"\"Iterate the specified tags.\"\"\" soupsieve.purge() \ue157 Soup Sieve caches compiled patterns for performance. If for whatever reason, you need to purge the cache, simply call purge . Namespaces \ue157 Many of Soup Sieve's selector functions take an optional namespace dictionary. Namespaces, just like CSS, must be defined for Soup Sieve to evaluate ns|tag type selectors. This is analogous to CSS's namespace at-rule: @ namespace url ( \"http://www.w3.org/1999/xhtml\" ) ; @ namespace svg url ( \"http://www.w3.org/2000/svg\" ) ; A namespace dictionary should have keys (prefixes) and values (namespaces). An empty key string for a key would denote the default key. An empty value would essentially represent a null namespace. To represent the above CSS example for Soup Sieve, we would configure it like so: namespace = { \"\" : \"http://www.w3.org/1999/xhtml\" , # Default namespace is for XHTML \"svg\" : \"http://www.w3.org/2000/svg\" , # The SVG namespace defined with prefix of \"svg\" } Tags do not necessarily have to have a prefix for Soup Sieve to recognize them. For instance, in HTML5, SVG should automatically get the SVG namespace. Depending how namespaces were defined in the documentation, tags may inherit namespaces in some conditions. Namespace assignment is mainly handled by the parser and exposed through the Beautiful Soup API. Soup Sieve uses the Beautiful Soup API to then compare namespaces for supported documents.","title":"API"},{"location":"api/#api","text":"Soup Sieve uses a subset of the CSS4 selector specification to detect and filter elements. To learn more about which specific selectors are implemented, see CSS Selectors . Soup Sieve will detect the document type being used from the Beautiful Soup object that is given to it, and depending on the document type, its behavior may be slightly different: All HTML document types (HTML, HTML5, and XHTML) will have their tag names and attribute names treated without case sensitivity, like most browsers do. Though XHTML is XML, which traditionally is case sensitive, it will still be treated like HTML in this respect. XML document types will have their tag names and attribute names treated with case sensitivity. HTML5, XHTML and XML document types will have namespaces evaluated per the document's support (provided via the parser). html5lib provides proper namespaces for HTML5, but lxml will not. If you need namespace support for HTML5, consider using html5lib . For XML, lxml will provide proper namespaces. It is generally suggested that lxml is used to parse XHTML documents. Some additional configuration is required when using namespaces, see Namespace for more information. While attribute values are generally treated as case sensitive, HTML5, XHTML, and HTML treat the type attribute special. The type attribute's value is always case insensitive. This is generally how most browsers treat type . If you need type to be sensitive, you can use the s flag: [ type = \"submit\" s ] . As far as the API is concerned, Soup Sieve mimics Beautiful Soup's original API at the time of writing this, which is why the names select and select_one are used. As of today, Beautiful Soup has agreed to include Soup Sieve as the official select library which is slated for the 4.7.0 release. Soup Sieve will always be available as an external API as well for more controlled tag selection if needed.","title":"API"},{"location":"api/#flags","text":"Early in development, flags were used to specify document type, but as of 1.0.0, there are no flags used at this time, but the parameter is provided for potential future use.","title":"Flags"},{"location":"api/#soupsieveselect_one","text":"def select ( select , tag , namespaces = None , flags = 0 ): \"\"\"Select the specified tags.\"\"\" select_one will return the first tag under the given tag that matches the given CSS selectors provided, or it will return None if a suitable tag was not found. select_one accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, and flags . >>> import soupsieve as sv >>> sv . select_one ( 'p:is(.a, .b, .c)' , soup ) <p class=\"a\">Cat</p>","title":"soupsieve.select_one()"},{"location":"api/#soupsieveselect","text":"def select ( select , tag , namespaces = None , limit = 0 , flags = 0 ): \"\"\"Select the specified tags.\"\"\" select will return all tags under the given tag that match the given CSS selectors provided. You can also limit the number of tags returned by providing a positive integer via the limit parameter (0 means to return all tags). select accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, a limit , and flags . >>> import soupsieve as sv >>> sv . select ( 'p:is(.a, .b, .c)' , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>]","title":"soupsieve.select()"},{"location":"api/#soupsieveiselect","text":"def iselect ( select , node , namespaces = None , limit = 0 , flags = 0 ): \"\"\"Select the specified tags.\"\"\" iselect is exactly like select except that it returns a generator instead of a list.","title":"soupsieve.iselect()"},{"location":"api/#soupsieveclosest","text":"def closest ( select , tag , namespaces = None , flags = 0 ): \"\"\"Match closest ancestor to the provided tag.\"\"\" closest returns the tag closest to the given tag that matches the given selector. The element found must be a direct ancestor of the tag or the tag itself. closest accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, and flags .","title":"soupsieve.closest()"},{"location":"api/#soupsievematch","text":"def match ( select , tag , namespaces = None , flags = 0 ): \"\"\"Match node.\"\"\" The match function matches a given tag with a given CSS selector. match accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, and flags. >>> nodes = sv . select ( 'p:is(.a, .b, .c)' , soup ) >>> sv . match ( 'p:not(.b)' , nodes [ 0 ]) True >>> sv . match ( 'p:not(.b)' , nodes [ 1 ]) False","title":"soupsieve.match()"},{"location":"api/#soupsievefilter","text":"def filter ( select , nodes , namespaces = None , flags = 0 ): \"\"\"Filter list of nodes.\"\"\" filter takes an iterable containing HTML nodes and will filter them based on the provided CSS selector string. If given a Tag / BeautifulSoup object, it will iterate the direct children filtering them. filter accepts a CSS selector string, an iterable containing nodes, an optional namespace dictionary, and flags. >>> sv . filter ( 'p:not(.b)' , soup . div ) [<p class=\"a\">Cat</p>, <p class=\"c\">Mouse</p>]","title":"soupsieve.filter()"},{"location":"api/#soupsievecomments","text":"def comments(tag, limit=0, flags=0): \"\"\"Get comments only.\"\"\" The comments function can be used to extract all comments from a document or document tag. It will return comments from the given tag down through all of its children. You can limit how many comments are returned with limit . comments accepts a Tag / BeautifulSoup object, a limit , and flags.","title":"soupsieve.comments()"},{"location":"api/#soupsieveicomments","text":"def icomments(node, limit=0, flags=0): \"\"\"Get comments only.\"\"\" icomments is exactly like comments except that it returns a generator instead of a list.","title":"soupsieve.icomments()"},{"location":"api/#soupsievecompile","text":"def compile ( pattern , namespaces = None , flags = 0 ): \"\"\"Compile CSS pattern.\"\"\" compile will pre-compile a CSS selector pattern returning a SoupSieve object. The SoupSieve object has the same selector functions available via the module without the need to specify the selector, namespaces, or flags. class SoupSieve : \"\"\"Match tags in Beautiful Soup with CSS selectors.\"\"\" def match ( self , tag ): \"\"\"Match.\"\"\" def closest ( self , tag ): \"\"\"Match closest ancestor.\"\"\" def filter ( self , iterable ): \"\"\"Filter.\"\"\" def comments ( self , tag , limit = 0 ): \"\"\"Get comments only.\"\"\" def icomments ( self , tag , limit = 0 ): \"\"\"Iterate comments only.\"\"\" def select_one ( self , tag ): \"\"\"Select a single tag.\"\"\" def select ( self , tag , limit = 0 ): \"\"\"Select the specified tags.\"\"\" def iselect ( self , tag , limit = 0 ): \"\"\"Iterate the specified tags.\"\"\"","title":"soupsieve.compile()"},{"location":"api/#soupsievepurge","text":"Soup Sieve caches compiled patterns for performance. If for whatever reason, you need to purge the cache, simply call purge .","title":"soupsieve.purge()"},{"location":"api/#namespaces","text":"Many of Soup Sieve's selector functions take an optional namespace dictionary. Namespaces, just like CSS, must be defined for Soup Sieve to evaluate ns|tag type selectors. This is analogous to CSS's namespace at-rule: @ namespace url ( \"http://www.w3.org/1999/xhtml\" ) ; @ namespace svg url ( \"http://www.w3.org/2000/svg\" ) ; A namespace dictionary should have keys (prefixes) and values (namespaces). An empty key string for a key would denote the default key. An empty value would essentially represent a null namespace. To represent the above CSS example for Soup Sieve, we would configure it like so: namespace = { \"\" : \"http://www.w3.org/1999/xhtml\" , # Default namespace is for XHTML \"svg\" : \"http://www.w3.org/2000/svg\" , # The SVG namespace defined with prefix of \"svg\" } Tags do not necessarily have to have a prefix for Soup Sieve to recognize them. For instance, in HTML5, SVG should automatically get the SVG namespace. Depending how namespaces were defined in the documentation, tags may inherit namespaces in some conditions. Namespace assignment is mainly handled by the parser and exposed through the Beautiful Soup API. Soup Sieve uses the Beautiful Soup API to then compare namespaces for supported documents.","title":"Namespaces"},{"location":"selectors/","text":"CSS Selectors \ue157 Level 1-4 Selectors \ue157 HTML and XML Selectors \ue157 The CSS selectors are based off of the CSS level 4 specification. Primarily support has been added for selectors that were feasible to implement and most likely to get practical use. Selectors that cannot provide meaningful matches will match nothing. An example would be :focus which will match nothing because elements cannot be focused outside of a browser. Though most of the selectors have been implemented, there are still a few that have not. Below shows accepted selectors. When speaking about namespaces, they only apply to XML, XHTML, or when dealing with recognized foreign tags in HTML5. You must configure the CSS namespaces when attempting to evaluate namespaces. While an effort is made to mimic CSS selector behavior, there may be some differences or quirks, please report issues if any are found. Selector Example Description Element div Select the < div > element (will be under the default namespace if defined for XHTML). Element, Element div , h1 Select the < div > element and the < h1 > element. Element Element div p Select all < p > elements inside < div > elements. Element>Element div > p Select all < p > elements where the parent is a < div > element. Element+Element div + p Select all < p > elements that are placed immediately after < div > elements. Element~Element p ~ ul Select every < ul > element that is preceded by a < p > element. namespace|Element svg | circle Select the < circle > element which also has the namespace svg . *|Element *| div Select the < div > element with or without a namespace. namespace|* svg |* Select any element with the namespace svg . |Element | div Select < div > elements without a namespace. |* |* Select any element without a namespace. *|* *|* Select all elements with any or no namespace. * * Select all elements. If a default namespace is defined, it will be any element under the default namespace. .class . some-class Select all elements with the class some-class . #id # some-id Select the element with the ID some-id . [attribute] [ target ] Selects all elements with a target attribute. [ns|attribute] [ xlink | href ] Selects elements with the attribute href and the namespace xlink (assuming it has been configured in the namespaces option). [*|attribute] [*| name ] Selects any element with a name attribute that has a namespace or not. [|attribute] [| name ] Selects any element with a name attribute. [|name] is equivalent to [name] . [attribute=value] [ target = _blank ] Selects all attributes with target=\"_blank\" . [attribute~=value] [ title ~= flower ] Selects all elements with a title attribute containing the word flower . [attribute|=value] [ lang |= en ] Selects all elements with a lang attribute value starting with en . [attribute^=value] a [ href ^= \"https\" ] Selects every < a > element whose href attribute value begins with https . [attribute$=value] a [ href $= \".pdf\" ] Selects every < a > element whose href attribute value ends with .pdf . [attribute*=value] a [ href *= \"sometext\" ] Selects every < a > element whose href attribute value contains the substring sometext . [attribute=value i] [ title = flower i ] Selects any element with a title that equals flower regardless of case. [attribute=value s] [ type = submit s ] Selects any element with a type that equals submit . Case sensitivity will be forced. :empty p : empty Selects every < p > element that has no children and either no text. Whitespace and comments are ignored. :first-child p : first-child Selects every < p > element that is the first child of its parent. :first-of-type p : first-of-type Selects every < p > element that is the first < p > element of its parent. :has(> sel, + sel) : has (> div , + p ) Selects elements that have a direct child that is a < div > or that have sibling of < p > immediately following. :is(sel, sel) : is ( div , . some-class ) Selects elements that are not < div > and do not have class some-class . The alias :matches is allowed as well. In CSS4 :where is like :is except specificity is always zero. Soup Sieve doesn't care about specificity, so :where is exactly like :is . :lang(l1, l2) : lang ( '*-CH' , en ) Select all elements with language de-CH , it-CH , fr-CH , and rm-CH . Will also match en , en-US , and en-GB . See CSS4 specification for more info. :last-child p : last-child Selects every < p > element that is the last child of its parent. :last-of-type p : last-of-type Selects every < p > element that is the last < p > element of its parent. :not(sel, sel) : not ( . some-class , # some-id ) Selects elements that do not have class some-class and ID some-id . :nth-child(an+b [of S]?) p : nth-child ( 2 ) Selects every < p > element that is the second child of its parent. Please see CSS specification for more info on format. :nth-last-child(an+b [of S]?) p : nth-last-child ( 2 ) Selects every < p > element that is the second child of its parent, counting from the last child. Please see CSS specification for more info on format. :nth-last-of-type(an+b) p : nth-last-of-type ( 2 ) Selects every < p > element that is the second < p > element of its parent, counting from the last child. Please see CSS specification for more info on format. :nth-of-type(an+b) p : nth-of-type ( 2 ) Selects every < p > element that is the second < p > element of its parent. Please see CSS specification for more info on format. :only-child p : only-child Selects every < p > element that is the only child of its parent. :only-of-type p : only-of-type Selects every < p > element that is the only < p > element of its parent. :root : root Selects the root element. In HTML, this is usually the < html > element. :scope : scope div Selects all < div > elements under the current scope element. :scope is the element under match or select. In the case where a document ( BeautifulSoup object, not a Tag object) is under select or match, :scope equals :root . Expensive Selectors Some selectors are more expensive to use than others. For instance, :has() can be a bit more expensive as :has(a) will search all children of every element to find if the element contains an < a > element. While an effort is made to prioritize evaluation of less expensive selectors first in the hopes to invalidate the search early on and avoid evaluating expensive selectors unless needed, you should still try to be as specific as possible to limit how often expensive selectors are evaluated. For instance, using p.special:has(a) will limit evaluating :has() to only < p > elements that contain the special class. CSS4 Selectors In general, CSS4 specific features and selectors are not finalized in the official CSS4 specification, and may change in the future. While some are most likely quite stable, some may be less certain. Some implementations are based off our interpretation of the specification. It is possible our interpretation is incorrect. This is more likely with selectors that currently have no reference implementations in browsers, such as :has() and of S support in :nth-child(an+b [of S]?) . If any issues are discovered please report the issue with details and examples so we can get them right. If at anytime CSS4 drops a selector from the current draft, it will most likely also be removed here, except in the rare case that the selector is found to be far too useful despite being rejected. Not Implemented Pseudo elements are not supported as they do not represent real elements. At-rules ( @page , etc.) are not supported. HTML Only Selectors \ue157 There are a number of selectors that apply specifically to HTML documents. Such selectors will only match tags in HTML documents. Use of these selectors are not restricted from XML, but when used with XML documents, they will never match. Selectors that require states that only exist within a live HTML document, or are specifically tied to user interaction with a live document are allowed (if implemented), but will never match as well. Selector Example Description :active a : active Active states are not applicable, so this will never match. :any-link a : any-link All links are treated as unvisited, so this will match every < a > element with an href attribute. :checked input : checked Selects every checked < input > element. :current p : current As the document is not rendered, this will never match. :current(sel, sel) : current ( p , li , dt , dd ) As the document is not rendered, this will never match. :default input : default Selects all < inputs > elements that are the default among their related elements. See CSS specification to learn more about all that this targets. :dir(direction) div : dir ( ltr ) Selects all < div > elements that have a text direction of left to right. :disabled input : disabled Selects every disabled < input > element. :enabled input : enabled Selects every enabled < input > element. :focus input : focus Focus states are not applicable, so this will never match. :future p : future As the document is not rendered, this will never match. :host : host Matches nothing as there is no Shadow DOM. :host(sel, sel) : host ( h1 ) Matches nothing as there is no Shadow DOM. :host-context(sel, sel) : host-context ( h1 ) Matches nothing as there is no Shadow DOM. :hover a : focus Focus states are not applicable, so this will never match. :link a : link All links are treated as unvisited, so this will match every < a > element with an href attribute. :optional input : optional Select every < input > element without a required attribute. :past p : past As the document is not rendered, this will never match. :paused : paused Pausing is not applicable in the Soup Sieve environment, so this will match nothing. :placeholder-shown input : placeholder-shown Selects every < input > element that is showing a placeholder via the placeholder attribute. :playing : playing Playing is not applicable in the Soup Sieve environment, so this will match nothing. :read-only input : read-only Selects every < input > element that is not editable by the user. :read-write input : read-write Selects every < input > element that is editable by the user. :required input : required Select every < input > element with a required attribute. :target # news : target Elements cannot be targeted, so this will never match. :user-invalid input : user-invalid User interaction is not applicable, so this will never match. :visited a : visited All links are treated unvisited, so this will never match. Custom Selectors \ue157 Below is a list of non-standard CSS selectors that we support. These can contain useful selectors that were rejected from the official CSS specifications, selectors implemented by other systems such as JQuery, or even selectors specifically created for Soup Sieve. Just because we include selectors from one source, does not mean we have intentions of implementing other selectors from the same such source. Selector Example Description [attribute!=value] [ target != _blank ] Equivalent to : not ([ target = _blank ]) . :contains(text) p : contains ( text ) Select all < p > elements that contain \"text\" in their content, either directly in themselves or indirectly in their descendants. Contains :contains() is an expensive operation as it scans all the text nodes of an element under consideration, which includes all descendants. Using highly specific selectors can reduce how often it is evaluated.","title":"CSS Selectors"},{"location":"selectors/#css-selectors","text":"","title":"CSS Selectors"},{"location":"selectors/#level-1-4-selectors","text":"","title":"Level 1-4 Selectors"},{"location":"selectors/#html-and-xml-selectors","text":"The CSS selectors are based off of the CSS level 4 specification. Primarily support has been added for selectors that were feasible to implement and most likely to get practical use. Selectors that cannot provide meaningful matches will match nothing. An example would be :focus which will match nothing because elements cannot be focused outside of a browser. Though most of the selectors have been implemented, there are still a few that have not. Below shows accepted selectors. When speaking about namespaces, they only apply to XML, XHTML, or when dealing with recognized foreign tags in HTML5. You must configure the CSS namespaces when attempting to evaluate namespaces. While an effort is made to mimic CSS selector behavior, there may be some differences or quirks, please report issues if any are found. Selector Example Description Element div Select the < div > element (will be under the default namespace if defined for XHTML). Element, Element div , h1 Select the < div > element and the < h1 > element. Element Element div p Select all < p > elements inside < div > elements. Element>Element div > p Select all < p > elements where the parent is a < div > element. Element+Element div + p Select all < p > elements that are placed immediately after < div > elements. Element~Element p ~ ul Select every < ul > element that is preceded by a < p > element. namespace|Element svg | circle Select the < circle > element which also has the namespace svg . *|Element *| div Select the < div > element with or without a namespace. namespace|* svg |* Select any element with the namespace svg . |Element | div Select < div > elements without a namespace. |* |* Select any element without a namespace. *|* *|* Select all elements with any or no namespace. * * Select all elements. If a default namespace is defined, it will be any element under the default namespace. .class . some-class Select all elements with the class some-class . #id # some-id Select the element with the ID some-id . [attribute] [ target ] Selects all elements with a target attribute. [ns|attribute] [ xlink | href ] Selects elements with the attribute href and the namespace xlink (assuming it has been configured in the namespaces option). [*|attribute] [*| name ] Selects any element with a name attribute that has a namespace or not. [|attribute] [| name ] Selects any element with a name attribute. [|name] is equivalent to [name] . [attribute=value] [ target = _blank ] Selects all attributes with target=\"_blank\" . [attribute~=value] [ title ~= flower ] Selects all elements with a title attribute containing the word flower . [attribute|=value] [ lang |= en ] Selects all elements with a lang attribute value starting with en . [attribute^=value] a [ href ^= \"https\" ] Selects every < a > element whose href attribute value begins with https . [attribute$=value] a [ href $= \".pdf\" ] Selects every < a > element whose href attribute value ends with .pdf . [attribute*=value] a [ href *= \"sometext\" ] Selects every < a > element whose href attribute value contains the substring sometext . [attribute=value i] [ title = flower i ] Selects any element with a title that equals flower regardless of case. [attribute=value s] [ type = submit s ] Selects any element with a type that equals submit . Case sensitivity will be forced. :empty p : empty Selects every < p > element that has no children and either no text. Whitespace and comments are ignored. :first-child p : first-child Selects every < p > element that is the first child of its parent. :first-of-type p : first-of-type Selects every < p > element that is the first < p > element of its parent. :has(> sel, + sel) : has (> div , + p ) Selects elements that have a direct child that is a < div > or that have sibling of < p > immediately following. :is(sel, sel) : is ( div , . some-class ) Selects elements that are not < div > and do not have class some-class . The alias :matches is allowed as well. In CSS4 :where is like :is except specificity is always zero. Soup Sieve doesn't care about specificity, so :where is exactly like :is . :lang(l1, l2) : lang ( '*-CH' , en ) Select all elements with language de-CH , it-CH , fr-CH , and rm-CH . Will also match en , en-US , and en-GB . See CSS4 specification for more info. :last-child p : last-child Selects every < p > element that is the last child of its parent. :last-of-type p : last-of-type Selects every < p > element that is the last < p > element of its parent. :not(sel, sel) : not ( . some-class , # some-id ) Selects elements that do not have class some-class and ID some-id . :nth-child(an+b [of S]?) p : nth-child ( 2 ) Selects every < p > element that is the second child of its parent. Please see CSS specification for more info on format. :nth-last-child(an+b [of S]?) p : nth-last-child ( 2 ) Selects every < p > element that is the second child of its parent, counting from the last child. Please see CSS specification for more info on format. :nth-last-of-type(an+b) p : nth-last-of-type ( 2 ) Selects every < p > element that is the second < p > element of its parent, counting from the last child. Please see CSS specification for more info on format. :nth-of-type(an+b) p : nth-of-type ( 2 ) Selects every < p > element that is the second < p > element of its parent. Please see CSS specification for more info on format. :only-child p : only-child Selects every < p > element that is the only child of its parent. :only-of-type p : only-of-type Selects every < p > element that is the only < p > element of its parent. :root : root Selects the root element. In HTML, this is usually the < html > element. :scope : scope div Selects all < div > elements under the current scope element. :scope is the element under match or select. In the case where a document ( BeautifulSoup object, not a Tag object) is under select or match, :scope equals :root . Expensive Selectors Some selectors are more expensive to use than others. For instance, :has() can be a bit more expensive as :has(a) will search all children of every element to find if the element contains an < a > element. While an effort is made to prioritize evaluation of less expensive selectors first in the hopes to invalidate the search early on and avoid evaluating expensive selectors unless needed, you should still try to be as specific as possible to limit how often expensive selectors are evaluated. For instance, using p.special:has(a) will limit evaluating :has() to only < p > elements that contain the special class. CSS4 Selectors In general, CSS4 specific features and selectors are not finalized in the official CSS4 specification, and may change in the future. While some are most likely quite stable, some may be less certain. Some implementations are based off our interpretation of the specification. It is possible our interpretation is incorrect. This is more likely with selectors that currently have no reference implementations in browsers, such as :has() and of S support in :nth-child(an+b [of S]?) . If any issues are discovered please report the issue with details and examples so we can get them right. If at anytime CSS4 drops a selector from the current draft, it will most likely also be removed here, except in the rare case that the selector is found to be far too useful despite being rejected. Not Implemented Pseudo elements are not supported as they do not represent real elements. At-rules ( @page , etc.) are not supported.","title":"HTML and XML Selectors"},{"location":"selectors/#html-only-selectors","text":"There are a number of selectors that apply specifically to HTML documents. Such selectors will only match tags in HTML documents. Use of these selectors are not restricted from XML, but when used with XML documents, they will never match. Selectors that require states that only exist within a live HTML document, or are specifically tied to user interaction with a live document are allowed (if implemented), but will never match as well. Selector Example Description :active a : active Active states are not applicable, so this will never match. :any-link a : any-link All links are treated as unvisited, so this will match every < a > element with an href attribute. :checked input : checked Selects every checked < input > element. :current p : current As the document is not rendered, this will never match. :current(sel, sel) : current ( p , li , dt , dd ) As the document is not rendered, this will never match. :default input : default Selects all < inputs > elements that are the default among their related elements. See CSS specification to learn more about all that this targets. :dir(direction) div : dir ( ltr ) Selects all < div > elements that have a text direction of left to right. :disabled input : disabled Selects every disabled < input > element. :enabled input : enabled Selects every enabled < input > element. :focus input : focus Focus states are not applicable, so this will never match. :future p : future As the document is not rendered, this will never match. :host : host Matches nothing as there is no Shadow DOM. :host(sel, sel) : host ( h1 ) Matches nothing as there is no Shadow DOM. :host-context(sel, sel) : host-context ( h1 ) Matches nothing as there is no Shadow DOM. :hover a : focus Focus states are not applicable, so this will never match. :link a : link All links are treated as unvisited, so this will match every < a > element with an href attribute. :optional input : optional Select every < input > element without a required attribute. :past p : past As the document is not rendered, this will never match. :paused : paused Pausing is not applicable in the Soup Sieve environment, so this will match nothing. :placeholder-shown input : placeholder-shown Selects every < input > element that is showing a placeholder via the placeholder attribute. :playing : playing Playing is not applicable in the Soup Sieve environment, so this will match nothing. :read-only input : read-only Selects every < input > element that is not editable by the user. :read-write input : read-write Selects every < input > element that is editable by the user. :required input : required Select every < input > element with a required attribute. :target # news : target Elements cannot be targeted, so this will never match. :user-invalid input : user-invalid User interaction is not applicable, so this will never match. :visited a : visited All links are treated unvisited, so this will never match.","title":"HTML Only Selectors"},{"location":"selectors/#custom-selectors","text":"Below is a list of non-standard CSS selectors that we support. These can contain useful selectors that were rejected from the official CSS specifications, selectors implemented by other systems such as JQuery, or even selectors specifically created for Soup Sieve. Just because we include selectors from one source, does not mean we have intentions of implementing other selectors from the same such source. Selector Example Description [attribute!=value] [ target != _blank ] Equivalent to : not ([ target = _blank ]) . :contains(text) p : contains ( text ) Select all < p > elements that contain \"text\" in their content, either directly in themselves or indirectly in their descendants. Contains :contains() is an expensive operation as it scans all the text nodes of an element under consideration, which includes all descendants. Using highly specific selectors can reduce how often it is evaluated.","title":"Custom Selectors"},{"location":"about/changelog/","text":"Changelog \ue157 1.6.0 \ue157 NEW : Add closest method to the API that matches closest ancestor. FIX : Add missing select_one reference to module's __all__ . 1.5.0 \ue157 NEW : Add select_one method like Beautiful Soup has. NEW : Add :dir() selector (HTML only). FIX : Fix issues when handling HTML fragments (elements without a BeautifulSoup object as a parent). FIX : Fix internal nth range check. 1.4.0 \ue157 NEW : Throw NotImplementedError for at-rules: @page , etc. NEW : Match nothing for :host , :host() , and :host-context() . NEW : Add support for :read-write and :read-only . NEW : Selector patterns can be annotated with CSS comments. FIX : \\r , \\n , and \\f cannot be escaped with \\ in CSS. You must use Unicode escapes. 1.3.1 \ue157 FIX : Fix issue with undefined namespaces. 1.3.0 \ue157 NEW : Add support for :scope . NEW : :user-invalid , :playing , :paused , and :local-link will not cause a failure, but all will match nothing as their use cases are not possible in an environment outside a web browser. FIX : Fix [attr~=value] handling of whitespace. According to the spec, if the value contains whitespace, or is an empty string, it should not match anything. FIX : Precompile internal patterns for pseudo-classes to prevent having to parse them again. 1.2.1 \ue157 FIX : More descriptive exceptions. Exceptions will also now mention position in the pattern that is problematic. FIX : filter ignores NavigableString objects in normal iterables and Tag iterables. Basically, it filters all Beautiful Soup document parts regardless of iterable type where as it used to only filter out a NavigableString in a Tag object. This is viewed as fixing an inconsistency. FIX : DEBUG flag has been added to help with debugging CSS selector parsing. This is mainly for development. FIX : If forced to search for language in meta tag, and no language is found, cache that there is no language in the meta tag to prevent searching again during the current select. FIX : If a non BeautifulSoup / Tag object is given to the API to compare against, raise a TypeError . 1.2.0 \ue157 NEW : Add Python 2.7 support. NEW : Remove old pre 1.0 deprecations. 1.1.0 \ue157 NEW : Adds support for [attr!=value] which is equivalent to :not([attr=value]) . NEW : Add support for :active , :focus , :hover , :visited , :target , :focus-within , :focus-visible , :target-within , :current() / :current , :past , and :future , but they will never match as these states don't exist in the Soup Sieve environment. NEW : Add support for :checked , :enabled , :disabled , :required , :optional , :default , and :placeholder-shown which will only match in HTML documents as these concepts are not defined in XML. NEW : Add support for :link and :any-link , both of which will target all <a> , <area> , and <link> elements with an href attribute as all links will be treated as unvisited in Soup Sieve. NEW : Add support for :lang() (CSS4) which works in XML and HTML. NEW : Users must install Beautiful Soup themselves. This requirement is removed in the hopes that Beautiful Soup may use this in the future. FIX : Attributes in the form prefix:attr can be matched with the form [prefix\\:attr] without specifying a namespaces if desired. FIX : Fix exception when [type] is used (with no value). 1.0.2 \ue157 FIX : Use proper CSS identifier patterns for tag names, classes, ids, etc. Things like #3 or #-3 should not match and should require #\\33 or #-\\33 . FIX : Do not raise NotImplementedError for supported pseudo classes/elements with bad syntax, instead raise SyntaxError . 1.0.1 \ue157 FIX : When giving a tag to select , it should only return the children of that tag, never the tag itself. FIX : For informational purposes, raise a NotImplementedError when an unsupported pseudo class is used. 1.0.0 \ue157 NEW : Official 1.0.0 release. 1.0.0b2 \ue157 NEW : Drop document flags. Document type can be detected from the Beautiful Soup object directly. FIX : CSS selectors should be evaluated with CSS whitespace rules. FIX : Processing instructions, CDATA, and declarations should all be ignored in :contains and child considerations for :empty . FIX : In Beautiful Soup, the document itself is the first tag. Do not match the \"document\" tag by returning false for any tag that doesn't have a parent. 1.0.0b1 \ue157 NEW : Add support for non-standard :contains() selector. FIX : Compare pseudo class names case insensitively when matching unexpected cases. FIX : Don't allow attribute case flags when no attribute value is defined. 0.6.0 \ue157 NEW : mode attribute is now called flags to allow for other options in the future. FIX : More corner cases for nth selectors. 0.5.3 \ue157 FIX : Previously, all pseudo classes' selector lists were evaluated as one big group, but now each pseudo classes' selector lists are evaluated separately. FIX : CSS selector tokens are not case sensitive. 0.5.2 \ue157 FIX : Add missing s flag to attribute selector for forced case sensitivity of attribute values. FIX : Relax attribute pattern matching to allow non-essential whitespace. FIX : Attribute selector flags themselves are not case sensitive. FIX : type attribute in HTML is handled special. While all other attributes values are case sensitive, type in HTML is usually treated special and is insensitive. In XML, this is not the case. 0.5.1 \ue157 FIX : Fix namespace check for :nth-of-type . 0.5.0 \ue157 NEW : Deprecate commentsiter and selectiter in favor of icomments and iselect . Expect removal in version 1.0. 0.4.0 \ue157 NEW : Initial prerelease.","title":"Changelog"},{"location":"about/changelog/#changelog","text":"","title":"Changelog"},{"location":"about/changelog/#160","text":"NEW : Add closest method to the API that matches closest ancestor. FIX : Add missing select_one reference to module's __all__ .","title":"1.6.0"},{"location":"about/changelog/#150","text":"NEW : Add select_one method like Beautiful Soup has. NEW : Add :dir() selector (HTML only). FIX : Fix issues when handling HTML fragments (elements without a BeautifulSoup object as a parent). FIX : Fix internal nth range check.","title":"1.5.0"},{"location":"about/changelog/#140","text":"NEW : Throw NotImplementedError for at-rules: @page , etc. NEW : Match nothing for :host , :host() , and :host-context() . NEW : Add support for :read-write and :read-only . NEW : Selector patterns can be annotated with CSS comments. FIX : \\r , \\n , and \\f cannot be escaped with \\ in CSS. You must use Unicode escapes.","title":"1.4.0"},{"location":"about/changelog/#131","text":"FIX : Fix issue with undefined namespaces.","title":"1.3.1"},{"location":"about/changelog/#130","text":"NEW : Add support for :scope . NEW : :user-invalid , :playing , :paused , and :local-link will not cause a failure, but all will match nothing as their use cases are not possible in an environment outside a web browser. FIX : Fix [attr~=value] handling of whitespace. According to the spec, if the value contains whitespace, or is an empty string, it should not match anything. FIX : Precompile internal patterns for pseudo-classes to prevent having to parse them again.","title":"1.3.0"},{"location":"about/changelog/#121","text":"FIX : More descriptive exceptions. Exceptions will also now mention position in the pattern that is problematic. FIX : filter ignores NavigableString objects in normal iterables and Tag iterables. Basically, it filters all Beautiful Soup document parts regardless of iterable type where as it used to only filter out a NavigableString in a Tag object. This is viewed as fixing an inconsistency. FIX : DEBUG flag has been added to help with debugging CSS selector parsing. This is mainly for development. FIX : If forced to search for language in meta tag, and no language is found, cache that there is no language in the meta tag to prevent searching again during the current select. FIX : If a non BeautifulSoup / Tag object is given to the API to compare against, raise a TypeError .","title":"1.2.1"},{"location":"about/changelog/#120","text":"NEW : Add Python 2.7 support. NEW : Remove old pre 1.0 deprecations.","title":"1.2.0"},{"location":"about/changelog/#110","text":"NEW : Adds support for [attr!=value] which is equivalent to :not([attr=value]) . NEW : Add support for :active , :focus , :hover , :visited , :target , :focus-within , :focus-visible , :target-within , :current() / :current , :past , and :future , but they will never match as these states don't exist in the Soup Sieve environment. NEW : Add support for :checked , :enabled , :disabled , :required , :optional , :default , and :placeholder-shown which will only match in HTML documents as these concepts are not defined in XML. NEW : Add support for :link and :any-link , both of which will target all <a> , <area> , and <link> elements with an href attribute as all links will be treated as unvisited in Soup Sieve. NEW : Add support for :lang() (CSS4) which works in XML and HTML. NEW : Users must install Beautiful Soup themselves. This requirement is removed in the hopes that Beautiful Soup may use this in the future. FIX : Attributes in the form prefix:attr can be matched with the form [prefix\\:attr] without specifying a namespaces if desired. FIX : Fix exception when [type] is used (with no value).","title":"1.1.0"},{"location":"about/changelog/#102","text":"FIX : Use proper CSS identifier patterns for tag names, classes, ids, etc. Things like #3 or #-3 should not match and should require #\\33 or #-\\33 . FIX : Do not raise NotImplementedError for supported pseudo classes/elements with bad syntax, instead raise SyntaxError .","title":"1.0.2"},{"location":"about/changelog/#101","text":"FIX : When giving a tag to select , it should only return the children of that tag, never the tag itself. FIX : For informational purposes, raise a NotImplementedError when an unsupported pseudo class is used.","title":"1.0.1"},{"location":"about/changelog/#100","text":"NEW : Official 1.0.0 release.","title":"1.0.0"},{"location":"about/changelog/#100b2","text":"NEW : Drop document flags. Document type can be detected from the Beautiful Soup object directly. FIX : CSS selectors should be evaluated with CSS whitespace rules. FIX : Processing instructions, CDATA, and declarations should all be ignored in :contains and child considerations for :empty . FIX : In Beautiful Soup, the document itself is the first tag. Do not match the \"document\" tag by returning false for any tag that doesn't have a parent.","title":"1.0.0b2"},{"location":"about/changelog/#100b1","text":"NEW : Add support for non-standard :contains() selector. FIX : Compare pseudo class names case insensitively when matching unexpected cases. FIX : Don't allow attribute case flags when no attribute value is defined.","title":"1.0.0b1"},{"location":"about/changelog/#060","text":"NEW : mode attribute is now called flags to allow for other options in the future. FIX : More corner cases for nth selectors.","title":"0.6.0"},{"location":"about/changelog/#053","text":"FIX : Previously, all pseudo classes' selector lists were evaluated as one big group, but now each pseudo classes' selector lists are evaluated separately. FIX : CSS selector tokens are not case sensitive.","title":"0.5.3"},{"location":"about/changelog/#052","text":"FIX : Add missing s flag to attribute selector for forced case sensitivity of attribute values. FIX : Relax attribute pattern matching to allow non-essential whitespace. FIX : Attribute selector flags themselves are not case sensitive. FIX : type attribute in HTML is handled special. While all other attributes values are case sensitive, type in HTML is usually treated special and is insensitive. In XML, this is not the case.","title":"0.5.2"},{"location":"about/changelog/#051","text":"FIX : Fix namespace check for :nth-of-type .","title":"0.5.1"},{"location":"about/changelog/#050","text":"NEW : Deprecate commentsiter and selectiter in favor of icomments and iselect . Expect removal in version 1.0.","title":"0.5.0"},{"location":"about/changelog/#040","text":"NEW : Initial prerelease.","title":"0.4.0"},{"location":"about/contributing/","text":"Contributing & Support \ue157 Bug Reports \ue157 Please read the documentation and search the issue tracker to try and find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much information as possible: Version being used. Operating system. Version of Python. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed. Reviewing Code \ue157 Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm. Answer Questions in Issues \ue157 Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for. Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others. Pull Requests \ue157 Pull requests are welcome, and a great way to help fix bugs and add new features. If you you are interested in directly contributing to the code, please check out Development for more information on the environment and processes. Documentation Improvements \ue157 A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the tool by helping to improve the documentation. Check out Development for more info on documentation.","title":"Contributing &amp; Support"},{"location":"about/contributing/#contributing--support","text":"","title":"Contributing &amp; Support"},{"location":"about/contributing/#bug-reports","text":"Please read the documentation and search the issue tracker to try and find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much information as possible: Version being used. Operating system. Version of Python. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed.","title":"Bug Reports"},{"location":"about/contributing/#reviewing-code","text":"Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.","title":"Reviewing Code"},{"location":"about/contributing/#answer-questions-in-issues","text":"Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for. Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others.","title":"Answer Questions in Issues"},{"location":"about/contributing/#pull-requests","text":"Pull requests are welcome, and a great way to help fix bugs and add new features. If you you are interested in directly contributing to the code, please check out Development for more information on the environment and processes.","title":"Pull Requests"},{"location":"about/contributing/#documentation-improvements","text":"A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the tool by helping to improve the documentation. Check out Development for more info on documentation.","title":"Documentation Improvements"},{"location":"about/development/","text":"Development \ue157 Project Layout \ue157 There are a number of files for build, test, and continuous integration in the root of the project, but in general, the project is broken up like so. \u251c\u2500\u2500 docs \u2502 \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 dictionary \u2502 \u2514\u2500\u2500 markdown \u251c\u2500\u2500 soupsieve \u251c\u2500\u2500 requirements \u2514\u2500\u2500 tests Directory Description docs/src/dictionary Contains the spell check wordlist(s) for the project. docs/src/markdown Contains the content for the documentation. soupsieve Contains the source code for the project. requirements Contains files with lists of dependencies that are required for the project, and required for continuous integration. tests Contains unit test files. Coding Standards \ue157 When writing code, the code should roughly conform to PEP8 and PEP257 suggestions. The project utilizes the Flake8 linter (with some additional plugins) to ensure code conforms (give or take some of the rules). When in doubt, follow the formatting hints of existing code when adding files or modifying existing files. Listed below are the modules used: pycqa/flake8 pycqa/flake8-docstrings pycqa/pep8-naming ebeweber/flake8-mutable gforcada/flake8-builtins Usually this can be automated with Tox (assuming it is installed): tox -e lint . Building and Editing Documents \ue157 Documents are in Markdown (with with some additional syntax provided by extensions) and are converted to HTML via Python Markdown. If you would like to build and preview the documentation, you must have these packages installed: Python-Markdown/markdown : the Markdown parser. mkdocs/mkdocs : the document site generator. squidfunk/mkdocs-material : a material theme for MkDocs. facelessuser/pymdown-extensions : this Python Markdown extension bundle. In order to build and preview the documents, just run the command below from the root of the project and you should be able to view the documents at localhost:8000 in your browser. After that, you should be able to update the documents and have your browser preview update live. mkdocs serve Spell Checking Documents \ue157 Spell checking is performed via facelessuser/pyspelling . During validation we build the docs and spell check various files in the project. Aspell must be installed and in the path. Currently this project uses one of the more recent versions of Aspell. It is not expected that everyone will install and run Aspell locally, but it will be run in CI tests for pull requests. In order to perform the spell check locally, it is expected you are setup to build the documents, and that you have Aspell installed in your system path (if needed you can use the --binary option to point to the location of your Aspell binary). It is also expected that you have the en dictionary installed as well. To initiate the spell check, run the following command from the root of the project. You will need to make sure the documents are built first: mkdocs build --clean And then run the spell checker. pyspelling It should print out the files with the misspelled words if any are found. If you find it prints words that are not misspelled, you can add them in docs/src/dictionary/en-custom.text . Validation Tests \ue157 In order to preserve good code health, a test suite has been put together with pytest ( pytest-dev/pytest ). To run these tests, you can use the following command: py.test Running Validation With Tox \ue157 Tox ( tox-dev/tox ) is a great way to run the validation tests, spelling checks, and linting in virtual environments so as not to mess with your current working environment. Tox will use the specified Python version for the given environment and create a virtual environment and install all the needed requirements (minus Aspell). You could also setup your own virtual environments with the Virtualenv module without Tox, and manually do the same. First, you need to have Tox installed: pip install tox By running Tox, it will walk through all the environments and create them (assuming you have all the python versions on your machine) and run the related tests. See tox.ini to learn more. tox If you don't have all the Python versions needed to test all the environments, those entries will fail. To run the tests for specific versions of Python, you specify the environment with -e PXY where X is the major version and Y is the minor version. tox -e py37 To target linting: tox -e lint To select spell checking and document building: tox -e documents Code Coverage \ue157 When running the validation tests through Tox, it is setup to track code coverage via the Coverage ( ned/coveragepy ) module. Coverage is run on each pyxx environment. If you've made changes to the code, you can clear the old coverage data: coverage erase Then run each unit test environment to generate coverage data. All the data from each run is merged together. HTML is output for each file in .tox/pyXX/tmp . You can use these to see areas that are not covered/exercised yet with testing. You can checkout tox.ini to see how this is accomplished. Code Documentation \ue157 The Soup Sieve module is laid out in the following structure: soupseive \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 __meta__.py \u251c\u2500\u2500 css_match.py \u251c\u2500\u2500 css_parser.py \u251c\u2500\u2500 css_types.py \u2514\u2500\u2500 util.py File Description __init__.py Contains the API for the user. __meta__.py Contains package meta data like version. css_match.py Contains the logic for matching tags with a CSS selector. css_parser.py Contains the CSS selector parser. css_types.py Contains the CSS types for the compiled CSS patterns. util.py Contains miscellaneous helper functions, classes, and constants. Compiled CSS Selector Structure \ue157 When a CSS selector string is given to Soup Sieve, it is run through the CSSParser class. CSSParser will return a SelectorList class. This class is sent to the SoupSieve class as a parameter along with things like namespace and flags . One of the most important things to understand when contributing is the structure of the SelectorList class. A SelectorList represents a list of compound selectors. So if you had the selector div > p , you would get a SelectorList object containing one Selector object. If you had div , p , you would get a SelectorList with two Selector objects as this is a selector list of two compound selectors. A compound selector gets parsed into pieces. Each part of a specific compound selector is usually assigned to an attribute in a single Selector object. The attributes of the Selector object may be as simple as a boolean or a string, but they can also be a tuple of more SelectorList objects. In the case of * : not ( p , div ) , * will be a SelectorList with one Selector . The : not ( p , div ) selector list will be a tuple containing one SelectorList of two Selectors (one for p and one for div ) under the selectors attribute of the * Selector . In short, Selectors are always contained within a SelectorList , and a compound selector is a single Selector object that may chain other SelectorLists objects depending on the complexity of the compound selector. If you provide a selector list, then you will get multiple Selector objects (one for each compound selector in the list) which in turn may chain other Selector objects. SelectorList \ue157 class SelectorList : \"\"\"Selector list.\"\"\" def __init__ ( self , selectors = tuple (), is_not = False ): \"\"\"Initialize.\"\"\" Attribute Description selectors A list of Selector objects. is_not The selectors in the selector list are from a :not() . is_html The selectors in the selector list are HTML specific. Selector \ue157 class Selector : \"\"\"Selector.\"\"\" def __init__ ( self , tag , ids , classes , attributes , nth , selectors , relation , rel_type , contains , lang , flags ): \"\"\"Initialize.\"\"\" Flags Description SEL_EMPTY The current compound selector contained an :empty pseudo-class. SEL_ROOT The current compound selector contains :root . SEL_DEFAULT The compound selector has a :default pattern and requires additional logic to determine if it is the first submit button in a form. SEL_INDETERMINATE The compound selector has a :indeterminate pattern and requires additional logic to ensure a radio element and all of the radio elements with the same name under a form are not set. Attribute Description tag Contains a single SelectorTag object, or None . id Contains a tuple of ids to match. Usually if multiple conflicting ids are present, it simply won't match a tag, but it allows multiple to handle the syntax tag#1#2 even if it is invalid. classes Contains a tuple of class names to match. attributes Contains a tuple of attributes. Each attribute is represented as a SelectorAttribute . nth Contains a tuple containing nth selectors, each selector being represented as a SelectorNth . nth selectors contain things like :first-child , :only-child , : nth-child () , : nth-of-type () , etc. selectors Contains a tuple of SelectorList objects for each pseudo-class selector part of the compound selector: : is () , : not () , : has () , etc. relation This will contain a SelectorList object with one Selector object, which could in turn chain an additional relation depending on the complexity of the compound selector. For instance, div > p + a would be a Selector for a that contains a relation for p (another SelectorList object) which also contains a relation of div . When matching, we would match that the tag is a , and then walk its relation chain verifying that they all match. In this case, the relation chain would be a direct, previous sibling of p , which has a direct parent of div . A :has() pseudo-class would walk this in the opposite order. div:has(> p + a) would verify div , and then check for a child of p with a sibling of a . rel_type rel_type is attached to relational selectors. In the case of div > p + a , the relational selectors of div and p would get a relational type of > and + respectively. :has() relational rel_type are preceded with : to signify a forward looking relation. contains Contains a tuple of strings of content to match in an element. lang Contains a tuple of SelectorLang objects. flags Selector flags that used to signal a type of selector is present. NullSelector \ue157 class NullSelector : \"\"\"Null Selector.\"\"\" def __init__ ( self ): \"\"\"Initialize.\"\"\" The null selector is like Selector , but it matches nothing. SelectorTag \ue157 class SelectorTag : \"\"\"Selector tag.\"\"\" def __init__ ( self , name , prefix ): \"\"\"Initialize.\"\"\" Attribute Description name name contains the tag name to match. prefix prefix contains the namespace prefix to match. prefix can also be None . SelectorAttribute \ue157 class SelectorAttribute : \"\"\"Selector attribute rule.\"\"\" def __init__ ( self , attribute , prefix , pattern , xml_type_pattern ): \"\"\"Initialize.\"\"\" Attribute Description attribute Contains the attribute name to match. prefix Contains the attribute namespace prefix to match if any. pattern Contains a re regular expression object that matches the desired attribute value. xml_type_pattern As the default type pattern is case insensitive, when the attribute value is type and a case sensitivity has not been explicitly defined, a secondary case sensitive type pattern is compiled for use with XML documents when detected. SelectorNth \ue157 class SelectorNth : \"\"\"Selector nth type.\"\"\" def __init__ ( self , a , n , b , of_type , last , selectors ): \"\"\"Initialize.\"\"\" Attribute Description a The a value in the formula an+b specifying an index. n True if the provided formula has included a literal n which signifies the formula is not a static index. b The b value in the formula an+b . type True if the nth pseudo-class is an *-of-type variant. last True if the nth pseudo-class is a *last* variant. selectors A SelectorList object representing the of S portion of :nth-chld(an+b [of S]?) . SelectorLang \ue157 class SelectorLang : \"\"\"Selector language rules.\"\"\" def __init__ ( self , languages ): \"\"\"Initialize.\"\"\" Attribute Description languages A list of regular expression objects that match a language pattern.","title":"Development"},{"location":"about/development/#development","text":"","title":"Development"},{"location":"about/development/#project-layout","text":"There are a number of files for build, test, and continuous integration in the root of the project, but in general, the project is broken up like so. \u251c\u2500\u2500 docs \u2502 \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 dictionary \u2502 \u2514\u2500\u2500 markdown \u251c\u2500\u2500 soupsieve \u251c\u2500\u2500 requirements \u2514\u2500\u2500 tests Directory Description docs/src/dictionary Contains the spell check wordlist(s) for the project. docs/src/markdown Contains the content for the documentation. soupsieve Contains the source code for the project. requirements Contains files with lists of dependencies that are required for the project, and required for continuous integration. tests Contains unit test files.","title":"Project Layout"},{"location":"about/development/#coding-standards","text":"When writing code, the code should roughly conform to PEP8 and PEP257 suggestions. The project utilizes the Flake8 linter (with some additional plugins) to ensure code conforms (give or take some of the rules). When in doubt, follow the formatting hints of existing code when adding files or modifying existing files. Listed below are the modules used: pycqa/flake8 pycqa/flake8-docstrings pycqa/pep8-naming ebeweber/flake8-mutable gforcada/flake8-builtins Usually this can be automated with Tox (assuming it is installed): tox -e lint .","title":"Coding Standards"},{"location":"about/development/#building-and-editing-documents","text":"Documents are in Markdown (with with some additional syntax provided by extensions) and are converted to HTML via Python Markdown. If you would like to build and preview the documentation, you must have these packages installed: Python-Markdown/markdown : the Markdown parser. mkdocs/mkdocs : the document site generator. squidfunk/mkdocs-material : a material theme for MkDocs. facelessuser/pymdown-extensions : this Python Markdown extension bundle. In order to build and preview the documents, just run the command below from the root of the project and you should be able to view the documents at localhost:8000 in your browser. After that, you should be able to update the documents and have your browser preview update live. mkdocs serve","title":"Building and Editing Documents"},{"location":"about/development/#spell-checking-documents","text":"Spell checking is performed via facelessuser/pyspelling . During validation we build the docs and spell check various files in the project. Aspell must be installed and in the path. Currently this project uses one of the more recent versions of Aspell. It is not expected that everyone will install and run Aspell locally, but it will be run in CI tests for pull requests. In order to perform the spell check locally, it is expected you are setup to build the documents, and that you have Aspell installed in your system path (if needed you can use the --binary option to point to the location of your Aspell binary). It is also expected that you have the en dictionary installed as well. To initiate the spell check, run the following command from the root of the project. You will need to make sure the documents are built first: mkdocs build --clean And then run the spell checker. pyspelling It should print out the files with the misspelled words if any are found. If you find it prints words that are not misspelled, you can add them in docs/src/dictionary/en-custom.text .","title":"Spell Checking Documents"},{"location":"about/development/#validation-tests","text":"In order to preserve good code health, a test suite has been put together with pytest ( pytest-dev/pytest ). To run these tests, you can use the following command: py.test","title":"Validation Tests"},{"location":"about/development/#running-validation-with-tox","text":"Tox ( tox-dev/tox ) is a great way to run the validation tests, spelling checks, and linting in virtual environments so as not to mess with your current working environment. Tox will use the specified Python version for the given environment and create a virtual environment and install all the needed requirements (minus Aspell). You could also setup your own virtual environments with the Virtualenv module without Tox, and manually do the same. First, you need to have Tox installed: pip install tox By running Tox, it will walk through all the environments and create them (assuming you have all the python versions on your machine) and run the related tests. See tox.ini to learn more. tox If you don't have all the Python versions needed to test all the environments, those entries will fail. To run the tests for specific versions of Python, you specify the environment with -e PXY where X is the major version and Y is the minor version. tox -e py37 To target linting: tox -e lint To select spell checking and document building: tox -e documents","title":"Running Validation With Tox"},{"location":"about/development/#code-coverage","text":"When running the validation tests through Tox, it is setup to track code coverage via the Coverage ( ned/coveragepy ) module. Coverage is run on each pyxx environment. If you've made changes to the code, you can clear the old coverage data: coverage erase Then run each unit test environment to generate coverage data. All the data from each run is merged together. HTML is output for each file in .tox/pyXX/tmp . You can use these to see areas that are not covered/exercised yet with testing. You can checkout tox.ini to see how this is accomplished.","title":"Code Coverage"},{"location":"about/development/#code-documentation","text":"The Soup Sieve module is laid out in the following structure: soupseive \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 __meta__.py \u251c\u2500\u2500 css_match.py \u251c\u2500\u2500 css_parser.py \u251c\u2500\u2500 css_types.py \u2514\u2500\u2500 util.py File Description __init__.py Contains the API for the user. __meta__.py Contains package meta data like version. css_match.py Contains the logic for matching tags with a CSS selector. css_parser.py Contains the CSS selector parser. css_types.py Contains the CSS types for the compiled CSS patterns. util.py Contains miscellaneous helper functions, classes, and constants.","title":"Code Documentation"},{"location":"about/development/#compiled-css-selector-structure","text":"When a CSS selector string is given to Soup Sieve, it is run through the CSSParser class. CSSParser will return a SelectorList class. This class is sent to the SoupSieve class as a parameter along with things like namespace and flags . One of the most important things to understand when contributing is the structure of the SelectorList class. A SelectorList represents a list of compound selectors. So if you had the selector div > p , you would get a SelectorList object containing one Selector object. If you had div , p , you would get a SelectorList with two Selector objects as this is a selector list of two compound selectors. A compound selector gets parsed into pieces. Each part of a specific compound selector is usually assigned to an attribute in a single Selector object. The attributes of the Selector object may be as simple as a boolean or a string, but they can also be a tuple of more SelectorList objects. In the case of * : not ( p , div ) , * will be a SelectorList with one Selector . The : not ( p , div ) selector list will be a tuple containing one SelectorList of two Selectors (one for p and one for div ) under the selectors attribute of the * Selector . In short, Selectors are always contained within a SelectorList , and a compound selector is a single Selector object that may chain other SelectorLists objects depending on the complexity of the compound selector. If you provide a selector list, then you will get multiple Selector objects (one for each compound selector in the list) which in turn may chain other Selector objects.","title":"Compiled CSS Selector Structure"},{"location":"about/development/#selectorlist","text":"class SelectorList : \"\"\"Selector list.\"\"\" def __init__ ( self , selectors = tuple (), is_not = False ): \"\"\"Initialize.\"\"\" Attribute Description selectors A list of Selector objects. is_not The selectors in the selector list are from a :not() . is_html The selectors in the selector list are HTML specific.","title":"SelectorList"},{"location":"about/development/#selector","text":"class Selector : \"\"\"Selector.\"\"\" def __init__ ( self , tag , ids , classes , attributes , nth , selectors , relation , rel_type , contains , lang , flags ): \"\"\"Initialize.\"\"\" Flags Description SEL_EMPTY The current compound selector contained an :empty pseudo-class. SEL_ROOT The current compound selector contains :root . SEL_DEFAULT The compound selector has a :default pattern and requires additional logic to determine if it is the first submit button in a form. SEL_INDETERMINATE The compound selector has a :indeterminate pattern and requires additional logic to ensure a radio element and all of the radio elements with the same name under a form are not set. Attribute Description tag Contains a single SelectorTag object, or None . id Contains a tuple of ids to match. Usually if multiple conflicting ids are present, it simply won't match a tag, but it allows multiple to handle the syntax tag#1#2 even if it is invalid. classes Contains a tuple of class names to match. attributes Contains a tuple of attributes. Each attribute is represented as a SelectorAttribute . nth Contains a tuple containing nth selectors, each selector being represented as a SelectorNth . nth selectors contain things like :first-child , :only-child , : nth-child () , : nth-of-type () , etc. selectors Contains a tuple of SelectorList objects for each pseudo-class selector part of the compound selector: : is () , : not () , : has () , etc. relation This will contain a SelectorList object with one Selector object, which could in turn chain an additional relation depending on the complexity of the compound selector. For instance, div > p + a would be a Selector for a that contains a relation for p (another SelectorList object) which also contains a relation of div . When matching, we would match that the tag is a , and then walk its relation chain verifying that they all match. In this case, the relation chain would be a direct, previous sibling of p , which has a direct parent of div . A :has() pseudo-class would walk this in the opposite order. div:has(> p + a) would verify div , and then check for a child of p with a sibling of a . rel_type rel_type is attached to relational selectors. In the case of div > p + a , the relational selectors of div and p would get a relational type of > and + respectively. :has() relational rel_type are preceded with : to signify a forward looking relation. contains Contains a tuple of strings of content to match in an element. lang Contains a tuple of SelectorLang objects. flags Selector flags that used to signal a type of selector is present.","title":"Selector"},{"location":"about/development/#nullselector","text":"class NullSelector : \"\"\"Null Selector.\"\"\" def __init__ ( self ): \"\"\"Initialize.\"\"\" The null selector is like Selector , but it matches nothing.","title":"NullSelector"},{"location":"about/development/#selectortag","text":"class SelectorTag : \"\"\"Selector tag.\"\"\" def __init__ ( self , name , prefix ): \"\"\"Initialize.\"\"\" Attribute Description name name contains the tag name to match. prefix prefix contains the namespace prefix to match. prefix can also be None .","title":"SelectorTag"},{"location":"about/development/#selectorattribute","text":"class SelectorAttribute : \"\"\"Selector attribute rule.\"\"\" def __init__ ( self , attribute , prefix , pattern , xml_type_pattern ): \"\"\"Initialize.\"\"\" Attribute Description attribute Contains the attribute name to match. prefix Contains the attribute namespace prefix to match if any. pattern Contains a re regular expression object that matches the desired attribute value. xml_type_pattern As the default type pattern is case insensitive, when the attribute value is type and a case sensitivity has not been explicitly defined, a secondary case sensitive type pattern is compiled for use with XML documents when detected.","title":"SelectorAttribute"},{"location":"about/development/#selectornth","text":"class SelectorNth : \"\"\"Selector nth type.\"\"\" def __init__ ( self , a , n , b , of_type , last , selectors ): \"\"\"Initialize.\"\"\" Attribute Description a The a value in the formula an+b specifying an index. n True if the provided formula has included a literal n which signifies the formula is not a static index. b The b value in the formula an+b . type True if the nth pseudo-class is an *-of-type variant. last True if the nth pseudo-class is a *last* variant. selectors A SelectorList object representing the of S portion of :nth-chld(an+b [of S]?) .","title":"SelectorNth"},{"location":"about/development/#selectorlang","text":"class SelectorLang : \"\"\"Selector language rules.\"\"\" def __init__ ( self , languages ): \"\"\"Initialize.\"\"\" Attribute Description languages A list of regular expression objects that match a language pattern.","title":"SelectorLang"},{"location":"about/license/","text":"License \ue157 MIT License Copyright \u00a9 2018 Isaac Muse isaacmuse@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#license","text":"MIT License Copyright \u00a9 2018 Isaac Muse isaacmuse@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"}]}